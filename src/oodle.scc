// oodle.scc
// Specifies the scanning rules for SableCC
// James Coleman, 2010

Package cps450.oodle;

Helpers
  letter = ['A'..'Z'] | ['a'..'z'];
  word_char = letter | '_';
  digit = ['0'..'9'];
  cr = 13;
  lf = 10;
  not_cr_lf = [[0..127] - [cr + lf]];
  newline = lf | cr lf;
  octal_digit = ['0'..'7'];
  non_string_char = ['"' + '\'];
  string_char = [not_cr_lf - non_string_char];
  escaped_sequence = '\t' | '\n' | '\f' | '\r' | '\"' | '\\' | '\' octal_digit octal_digit octal_digit;
  string_contents = (string_char* escaped_sequence*)*;
  
Tokens
  if = 'if';
  while = 'while';
  boolean = 'boolean';
  begin = 'begin';
  klass = 'class';
  else = 'else';
  end = 'end';
  false = 'false';
  from = 'from';
  inherits = 'inherits';
  int = 'int';
  is = 'is';
  loop = 'loop';
  me = 'me';
  new = 'new';
  not = 'not';
  null = 'null';
  string = 'string';
  then = 'then';
  true = 'true';
  and = 'and';
  or = 'or';
  
  bang = '!';

  comma = ',';
  semicolon = ';';
  colon = ':';
  period = '.';

  gte_op = '>=';
  gt_op = '>';
  eq_op = '=';

  plus_op = '+';
  minus_op = '-';
  mult_op = '*';
  div_op = '/';
  
  concat_op = '&';

  l_par = '(';
  r_par = ')';
  
  assignment_op = ':=';
  l_bracket = '[';
  r_bracket = ']';

  id = word_char (word_char | digit)*;
  
  intlit = digit+ | '-' digit+;
  
  strlit = '"' string_contents '"';
  illegal_string = '"' (string_char | '\')* '"';
  unterminated_string = '"' string_contents;

  continuation = '_' newline;
  eol = newline;

  blank = (' ' | 9)+;
  comment = '~' not_cr_lf*;
  
  illegal_char = [0..127];
	
Ignored Tokens
  
  blank, continuation, comment;
  

Productions
  start = [begin]:T.eol* class_def class_tail* [end]:T.eol*;
  
  class_tail = T.eol* class_def;
  class_inheritance = T.inherits T.from id;
  class_def = T.klass [begin]:T.id class_inheritance? T.is T.eol*
              var_declaration*
              method_declaration*
              T.end [class_end]:T.id;
  
  var_declaration = T.id var_type_declaration? var_instantiation? T.eol*;
  var_type_declaration = T.colon var_type;
  var_instantiation = T.assignment_op expression;
  
  method_declaration = [method_dec_begin]:id T.l_par argument_list? T.r_par var_type? T.is [method_begin]:T.eol*
                       var_declaration*
                       T.begin [method_middle]:T.eol*
                       statement_list
                       T.end [method_dec_end]:T.id [method_end]:T.eol*;
  
  argument_list = argument_declaration_head* argument_declaration;
  argument_declaration_head = argument_declaration T.semicolon;
  argument_declaration = T.id var_type;
  
  var_type = {int} T.int | {string} T.string | {boolean} T.boolean | {id} T.id | {array} array_var_type;
  array_var_type = {test2} var_type T.l_bracket expression T.r_bracket;
  
  statement_list = statement_head*;
  statement_head = statement T.eol*;
  statement = {assignment} assignment_statement | {if} if_statement | {loop} loop_statement | {call} call_statement;
  
  assignment_statement = {test3} T.id bracket_operation* var_instantiation;
  
  if_statement = {test4} [begin_if]:T.if expression T.then T.eol*
                 statement_list
                 if_statement_else?
                 T.end [if_end]:T.if;
  if_statement_else = T.else T.eol*
                      statement_list;
  
  loop_statement = {test5} [loop_begin]:T.loop T.while expression T.eol*
                   statement_list
                   T.end [loop_end]:T.loop;
  
  call_statement = {object} object_call | {normal} method_call;
  
  
  expression_list = expression_head* expression;
  expression_head = expression T.comma;
  
  unary_operator = {negate} T.minus_op | {not} T.not;
  mult_operator = {multiply} T.mult_op | {divide} T.div_op;
  add_operator = {add} T.plus_op | {subtract} T.minus_op;
  relational_operator = {equal} T.eq_op | {greater} T.gt_op | {greater_equal} T.gte_op;
  object_call = object_call_expression T.period method_call;
  method_call = T.id T.l_par expression_list T.r_par;
  bracket_operation = T.l_bracket expression T.r_bracket;
  get_at_reference = T.id bracket_operation;
  
  expression = or_expression;
  or_expression = {or} or_expression T.or and_expression | {expr1} and_expression;
  and_expression = {and} and_expression T.and relational_expression | {expr2} relational_expression;
  relational_expression = {relational} [first]:concat_expression relational_operator [second]:concat_expression | {expr3} concat_expression;
  concat_expression = {concat} concat_expression T.concat_op add_expression | {expr4} add_expression;
  add_expression = {add} add_expression add_operator mult_expression | {expr5} mult_expression;
  mult_expression = {mult} mult_expression mult_operator call_expression | {expr6} unary_expression;
  unary_expression = {unary} unary_operator unary_expression | {expr7} group_expression;
  group_expression = {group} T.l_par expression T.r_par | {expr8} object_call_expression;
  object_call_expression = {get_at} get_at_reference | {call} object_call | {expr9} call_expression;
  call_expression = {call} method_call | {expr10} real_expression;
  real_expression = {id} T.id
                    | {string} T.strlit | {int} T.intlit
                    | {true} T.true | {false} T.false | {null} T.null | {me} T.me
                    | {new} T.new var_type;
  
  
  
  
  
  
  
  